import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split, cross_val_score, KFold
from sklearn.preprocessing import StandardScaler, PolynomialFeatures
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.neural_network import MLPRegressor
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

class RegressionModels:
    def __init__(self):
        self.models = {
            'Linear': LinearRegression(),
            'Polynomial': Pipeline([
                ('poly', PolynomialFeatures(degree=2)),
                ('linear', LinearRegression())
            ]),
            'RandomForest': RandomForestRegressor(
                n_estimators=100, 
                criterion='squared_error',
                max_depth=None,
                min_samples_split=2,
                min_samples_leaf=1,
                max_features=1.0,
                bootstrap=True,
                random_state=42
            ),
            'GradientBoosting': GradientBoostingRegressor(
                n_estimators=500,
                max_depth=4,
                min_samples_split=5,
                learning_rate=0.01,
                loss='squared_error',
                random_state=42
            ),
            'MLP': MLPRegressor(
                hidden_layer_sizes=(10,)*5,
                activation='relu',
                solver='adam',
                batch_size=32,
                learning_rate='constant',
                learning_rate_init=0.001,
                max_iter=100,
                early_stopping=True,
                validation_fraction=0.2,
                n_iter_no_change=20,
                random_state=42
            )
        }
        self.scores = {}
        self.predictions = {}
        self.cv_scores = {}
        self.scaler = StandardScaler()
        
    def perform_cross_validation(self, X, y):
        kfold = KFold(n_splits=5, shuffle=True, random_state=42)
        cv_results = {}
        
        for name, model in self.models.items():
            r2_scores = cross_val_score(model, X, y, cv=kfold, scoring='r2')
            rmse_scores = np.sqrt(-cross_val_score(model, X, y, cv=kfold, 
                                                 scoring='neg_mean_squared_error'))
            
            cv_results[name] = {
                'r2_mean': r2_scores.mean(),
                'r2_std': r2_scores.std(),
                'rmse_mean': rmse_scores.mean(),
                'rmse_std': rmse_scores.std()
            }
            
        return cv_results

    def evaluate_model(self, model_name):
        model = self.models[model_name]
        
        # Make predictions
        y_train_pred = model.predict(self.X_train_scaled)
        y_test_pred = model.predict(self.X_test_scaled)
        
        # Store predictions
        self.predictions[model_name] = {
            'train': y_train_pred,
            'test': y_test_pred
        }
        
        # Calculate metrics
        self.scores[model_name] = {
            'train_rmse': np.sqrt(mean_squared_error(self.y_train, y_train_pred)),
            'test_rmse': np.sqrt(mean_squared_error(self.y_test, y_test_pred)),
            'train_r2': r2_score(self.y_train, y_train_pred),
            'test_r2': r2_score(self.y_test, y_test_pred)
        }

    def train_all_models(self):
        for name, model in self.models.items():
            print(f"\nTraining {name}...")
            model.fit(self.X_train_scaled, self.y_train)
            self.evaluate_model(name)
            
        # Perform cross-validation
        self.cv_scores = self.perform_cross_validation(self.X_train_scaled, self.y_train)

    # [Rest of the class methods remain the same: read_excel_data, prepare_data, 
    # process_all_datasets, get_feature_importance, plot_results, print_metrics]
